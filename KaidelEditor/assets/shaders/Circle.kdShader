#type vertex

struct VertexInput
{
    float3 a_Position : POSITION0;
    float3 a_LocalPosition : POSITION1;
    float4 a_Color : COLOR;
    float a_Thickness : TEXCOORD0;
    float a_Fade : TEXCOORD1;
    int a_EntityID : TEXCOORD2;
};

cbuffer Camera : register(b0)
{
    matrix u_ViewProjection;
};

struct VertexOutput
{
	float4 Position : SV_Position;
    float3 LocalPosition : POSITION;
    float4 Color : COLOR;
    float Thickness : TEXCOORD0;
    float Fade : TEXCOORD1;
	nointerpolation int EntityID : TEXCOORD2;
};

VertexOutput main(VertexInput input)
{
    VertexOutput output;
	output.Position = mul(float4(input.a_Position,1.0f),u_ViewProjection);
    output.LocalPosition = input.a_LocalPosition;
    output.Color = input.a_Color;
    output.Thickness = input.a_Thickness;
    output.Fade = input.a_Fade;

	output.EntityID = input.a_EntityID;
    return output;
}

#type fragment

struct VertexOutput
{
    float3 LocalPosition : POSITION;
    float4 Color : COLOR;
    float Thickness : TEXCOORD0;
    float Fade : TEXCOORD1;
	nointerpolation int EntityID : TEXCOORD2;
};

struct PSOutput{
	float4 Color : SV_Target0;
	int EntityID : SV_Target1;

};

PSOutput main(VertexOutput Input) : SV_TARGET0
{
	PSOutput output;
    float distance = 1.0 - length(Input.LocalPosition);
    float c = smoothstep(0.0, Input.Fade, distance);
    c *= smoothstep(Input.Thickness + Input.Fade, Input.Thickness, distance);
    
    if (c == 0.0)
        discard;
    
    float4 color;
    color.rgb = Input.Color.rgb;
    color.a = Input.Color.a * c;
    
    output.Color = color;
    output.EntityID= Input.EntityID;
	return output;
}
